(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{510:function(t,a,s){"use strict";s.r(a);var e=s(0),v=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"git-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-简介"}},[t._v("#")]),t._v(" Git 简介")]),t._v(" "),a("h3",{attrs:{id:"安装-git"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装-git"}},[t._v("#")]),t._v(" 安装 Git")]),t._v(" "),a("p",[t._v("Window：在 Git 官网直接下载安装程序即可。")]),t._v(" "),a("p",[t._v("Git 配置：")]),t._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" config "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--global")]),t._v(" user.name "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Your Name"')]),t._v("\n$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" config "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("--global")]),t._v(" user.email "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"email@example.com"')]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("blockquote",[a("p",[t._v("git config 命令的--global 参数，用了这个参数，表示你这台机器上所有的 Git 仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和 Email 地址。")])]),t._v(" "),a("h3",{attrs:{id:"创建版本库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建版本库"}},[t._v("#")]),t._v(" 创建版本库")]),t._v(" "),a("p",[t._v("第一步，选择合适的路径，创建空目录。")]),t._v(" "),a("p",[t._v("第二步，通过"),a("code",[t._v("git init")]),t._v("命令把这个目录变成 Git 可以管理的仓库，此时目录下会创建"),a("code",[t._v(".git")]),t._v("目录文件，用来跟踪管理版本库的。")]),t._v(" "),a("p",[t._v("第三步，把文件添加到版本库。")]),t._v(" "),a("p",[t._v("版本控制系统只能跟踪文本文件的改动，比如.txt、网页、程序代码等。对于 word 文件是跟踪不了的，因为它是二进制格式文件。同时要主要要跟踪的文本是有编码的，一般采用 UTF-8 标准。")]),t._v(" "),a("p",[t._v("把文件放到 Git 仓库只需要两步：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("git add")]),t._v("告诉 Git，把文件添加到仓库的暂存区；")]),t._v(" "),a("li",[a("code",[t._v("git commit")]),t._v("告诉 Git，把文件从暂存区提交到对应分支的仓库。")])]),t._v(" "),a("h2",{attrs:{id:"git-仓库版本切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#git-仓库版本切换"}},[t._v("#")]),t._v(" Git 仓库版本切换")]),t._v(" "),a("h3",{attrs:{id:"版本回退"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本回退"}},[t._v("#")]),t._v(" 版本回退")]),t._v(" "),a("p",[a("code",[t._v("HEAD")]),t._v("指向的版本是当前版本，可以通过"),a("code",[t._v("git reset --hard HEAD^")]),t._v("回退到上一个版本。")]),t._v(" "),a("p",[a("code",[t._v("git log")]),t._v("可以查看版本库的状态，以便确定要回退到哪个版本。")]),t._v(" "),a("p",[a("code",[t._v("git reflog")]),t._v("用来查看命令历史记录，可以查看回退之前的版本号。")]),t._v(" "),a("p",[a("code",[t._v("git reset --hard commit_id")]),t._v("用来指定回到某个版本。")]),t._v(" "),a("h3",{attrs:{id:"工作区和暂存区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作区和暂存区"}},[t._v("#")]),t._v(" 工作区和暂存区")]),t._v(" "),a("p",[t._v("工作区（Working Directory）：电脑里面文件的目录。")]),t._v(" "),a("p",[t._v("版本库（Repository）：工作区有一个隐藏目录"),a("code",[t._v(".git")]),t._v("，是 Git 的版本库。")]),t._v(" "),a("ul",[a("li",[t._v("stage（或者叫 index）暂存区")]),t._v(" "),a("li",[t._v("git 自动创建的第一个分支 master，以及指向master的一个指针叫HEAD")])]),t._v(" "),a("p",[t._v("我们将文件添加到版本库的时候，第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。")]),t._v(" "),a("p",[a("code",[t._v("git status")]),t._v("用来查看当前git仓库的提交状态,可以查看文件是否修改、是否加入暂存区以及是否提交到仓库。")]),t._v(" "),a("h3",{attrs:{id:"撤销修改"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#撤销修改"}},[t._v("#")]),t._v(" 撤销修改")]),t._v(" "),a("p",[t._v("当修改错了工作区某个文件的内容时候，想直接丢弃工作区的修改时（此时还未提交到暂存区），使用"),a("code",[t._v("git restore <file>...")]),t._v(" to discard changes in working directory；")]),t._v(" "),a("p",[t._v("如果把工作区的内容添加到了暂存区，从暂存区恢复工作区命令："),a("code",[t._v("git restore --staged <file>")]),t._v("；")]),t._v(" "),a("p",[t._v("如果将暂存区的内容提交到仓库，即提交了不合适的修改到版本库，要想撤销本次提交，可以利用HEAD进行版本回退，前提是没有将版本库推送到远程库！")]),t._v(" "),a("h2",{attrs:{id:"远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程仓库"}},[t._v("#")]),t._v(" 远程仓库")]),t._v(" "),a("p",[t._v("远程仓库用来存储原始的版本库，这样子我们可以在多台电脑上克隆这个版本库，而且包含所有的版本控制信息，适合多人协作，或者自己在不同的电脑上来回切换工作。Github就是这样的远程仓库，那么本地仓库和Github仓库之间怎么传输的呢？是通过SSH加密传输的，所以需要设置公钥和私钥。")]),t._v(" "),a("h3",{attrs:{id:"远程仓库与本地仓库的连接"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程仓库与本地仓库的连接"}},[t._v("#")]),t._v(" 远程仓库与本地仓库的连接")]),t._v(" "),a("ul",[a("li",[t._v("第一步，创建SSH Key。")])]),t._v(" "),a("p",[t._v("通过"),a("code",[t._v('ssh-keygen -t rsa -C "youremail@example.com"')]),t._v("创建SSH Key，会生成"),a("code",[t._v("id_rsa")]),t._v("和"),a("code",[t._v("id_rsa.pub")]),t._v("密钥对，分别代表私钥和公钥。")]),t._v(" "),a("ul",[a("li",[t._v("第二步，登陆Github，将公钥添加到"),a("code",[t._v("SSH Keys")]),t._v("设置中。")])]),t._v(" "),a("p",[t._v("为什么Github需要SSH-keys呢？因为Github需要确保你推送的提交的确是你自己推送的，而不是别人冒充推送的，同时Git支持SSH协议，因此把公钥交给Github，就可以确认是本人推送的。如果你有多台电脑的话，可以每台电脑都生成SSH keys，然后将公钥添加到Github的设置中保存。")]),t._v(" "),a("h3",{attrs:{id:"添加远程仓库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#添加远程仓库"}},[t._v("#")]),t._v(" 添加远程仓库")]),t._v(" "),a("p",[t._v("要想实现本地仓库和远程仓库同步，远程仓库既可以作为版本库的备份，又可以让其他人通过该仓库来协作。")]),t._v(" "),a("ol",[a("li",[t._v("在Github上创建一个新的仓库repo；")])]),t._v(" "),a("p",[t._v("可以通过这个repo仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到Github的仓库中。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("远程仓库与本地仓库的关联；")])]),t._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" remote "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),t._v(" origin git@github.com:hongzhangfa/hongzhangfa-blog.git\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("将本地仓库内容推送到远程仓库；")])]),t._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" push "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-u")]),t._v(" origin master\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("上述命令是将当前分支master推送到远程；由于远程库是空的，我们第一次推送master分支时。加上了"),a("code",[t._v("-u")]),t._v("参数，Git不但会把本地的master分支内容推送到远程的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送和拉取时候就可以简化命令。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("之前将本地内容推送到远程")])]),t._v(" "),a("p",[t._v("直接通过命令"),a("code",[t._v("git push origin master")]),t._v("，即将本地master分支最新修改推送到Github的origin/master分支。")]),t._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[t._v("删除远程库")])]),t._v(" "),a("p",[t._v("如果连接远程仓库写错了，可以通过"),a("code",[t._v("git remote -v")]),t._v("查看远程库信息，然后"),a("code",[t._v("git remote rm <name>")]),t._v("根据仓库名字删除远程仓库，本质解除本地和远程库的关联。")]),t._v(" "),a("h3",{attrs:{id:"从远程仓库克隆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从远程仓库克隆"}},[t._v("#")]),t._v(" 从远程仓库克隆")]),t._v(" "),a("p",[t._v("我们在自己开发时候，或者在Github仓库找开源项目时，一般都是从远程仓库拉取到本地再进行开发。")]),t._v(" "),a("ol",[a("li",[t._v("Github创建新仓库，或找到一个开源仓库；")]),t._v(" "),a("li",[t._v("选取克隆的方式，一般为https或ssh，通过命令来克隆到本地:"),a("code",[t._v("git clone <githubUrl>")]),t._v("；")])]),t._v(" "),a("p",[t._v("Git支持多种协议，包括https，但是ssh协议速度最快（需要将ssh生成的公钥添加到github）")]),t._v(" "),a("h2",{attrs:{id:"分支管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支管理"}},[t._v("#")]),t._v(" 分支管理")]),t._v(" "),a("p",[t._v("在项目开发过程中，不过是多人协作还是进行新功能的开发，都需要用到Git的分支管理，这样可以让开发效率更高。")]),t._v(" "),a("h3",{attrs:{id:"创建与合并分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建与合并分支"}},[t._v("#")]),t._v(" 创建与合并分支")]),t._v(" "),a("ol",[a("li",[t._v("创建分支，然后切换到该分支")])]),t._v(" "),a("div",{staticClass:"language-sh line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("// 第一种方式\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-b")]),t._v(" dev\n// 第二种方式\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" branch dev\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" checkout dev\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br")])]),a("ol",{attrs:{start:"2"}},[a("li",[t._v("命令查看当前分支"),a("code",[t._v("git branch")])]),t._v(" "),a("li",[t._v("在当前分支正常提交")]),t._v(" "),a("li",[t._v("切换回master分支："),a("code",[t._v("git switch master")])]),t._v(" "),a("li",[t._v("将dev分支内容合并到master分支上："),a("code",[t._v("git merge dev")])]),t._v(" "),a("li",[t._v("删除已经合并完成的分支："),a("code",[t._v("git branch -d dev")])])]),t._v(" "),a("h3",{attrs:{id:"解决合并分支冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决合并分支冲突"}},[t._v("#")]),t._v(" 解决合并分支冲突")]),t._v(" "),a("p",[t._v("通过分支开发的代码，最终都要合并到master上，如果两者都改动了同一个地方，就会产生冲突，这个时候需要手动解决冲突后再提交。")]),t._v(" "),a("h3",{attrs:{id:"分支管理策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分支管理策略"}},[t._v("#")]),t._v(" 分支管理策略")]),t._v(" "),a("p",[t._v("通常合并分支，Git会用Fast forward模式，相当于将master指针直接移到当前分支的指针，但在这种模式下，删除分支后，就会丢失分支信息。")]),t._v(" "),a("p",[t._v("采用强制禁用Fast forward模式的话，Git就会在merge时生成一个新的commit，这样在分支历史上就可以看出分支信息："),a("code",[t._v('git merge --no-ff -m "merge with no-ff" dev')])]),t._v(" "),a("h3",{attrs:{id:"bug分支"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bug分支"}},[t._v("#")]),t._v(" bug分支")]),t._v(" "),a("p",[t._v("出现临时bug需要修复时，而自己当前dev分支工作还没有完成，暂时不能提交，需要"),a("code",[t._v("git stash")]),t._v("将当前工作内容储藏起来，先去修复bug。")]),t._v(" "),a("p",[t._v("然后确定在哪个分支上修复bug，从而创建分支来修复bug，修复之后将分支合并到出bug的分支，然后删除分支。同时要注意一个问题，如果你当前工作的分支是由出bug的分支分出来的话，该怎么办呢？难道重新再修复一下bug吗？不需要！通过"),a("code",[t._v("git cherry-pick <commit_id>")]),t._v("命令来修复，修复完成之后会创建一个新的提交。")])])}),[],!1,null,null,null);a.default=v.exports}}]);